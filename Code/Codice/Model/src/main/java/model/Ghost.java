/*
* This code has been generated by the Rebel: a code generator for modern Java.
*
* Drop us a line or two at feedback@archetypesoftware.com: we would love to hear from you!
*/
package model;

import java.util.*;

import javax.imageio.ImageIO;

import view.GameEngine;

import java.io.IOException;

//fantasmini
public class Ghost extends Entity {
		private GameEngine gp;
		private String ultimoMovimentoOpposto = null;
		
		public Ghost(GameEngine gp, int i) {
			super(gp);
			//
			this.gp=gp;
			name="fanstasma "+i;
			direction="left";
			speed=3;
			type=i;
			solidArea.x=3;
			solidArea.y=7;
			solidArea.height=35;
			solidArea.width=35;
			solidAreaDefaultx = solidArea.x;
			solidAreaDefaulty = solidArea.y;
			
			getImage(i);
			
			fantasmaVulnerabile();
		}

		private void getImage(int immagine) {
			if(immagine==1) {
				try {
					imageGhost = ImageIO.read(getClass().getResourceAsStream("/pacman/fanstasmi/ROSSO.gif"));
				}catch(IOException e) {
					e.printStackTrace();
				}
			}
			if(immagine==2) {
				try {
					imageGhost = ImageIO.read(getClass().getResourceAsStream("/pacman/fanstasmi/TURCHE.gif"));
				}catch(IOException e) {
					e.printStackTrace();
				}
			}
			if(immagine==3) {
				try {
					imageGhost = ImageIO.read(getClass().getResourceAsStream("/pacman/fanstasmi/SALMONE.gif"));
				}catch(IOException e) {
					e.printStackTrace();
				}
			}
			if(immagine==4) {
				try {
					imageGhost = ImageIO.read(getClass().getResourceAsStream("/pacman/fanstasmi/ROSA.gif"));
				}catch(IOException e) {
					e.printStackTrace();
				}
			}
			
		}
		private void fantasmaVulnerabile() {
			try {
				imageFantasma_vunerabile = ImageIO.read(getClass().getResourceAsStream("/pacman/fanstasmi/fantasma_vulnerabile.gif"));
			}catch(IOException e) {
				e.printStackTrace();
			}
		}
		public int getType() {
			return type;
		}
		private void randomMovement() {
			actionlockCounter++;
			
			if (actionlockCounter == 50) {
				Random random = new Random();
			     int i = ((Random) random).nextInt(100)+1;
			     
			     do{
			    	 i = ((Random) random).nextInt(100)+1;
			    	 if(i <= 25 ){
					        direction = "up";
					        
					       
					 }
			    	 if (i > 25 && i <= 50) {
					        direction ="left";
					        
					        
			    	 }
			    	 if (i > 50 && i <= 75) {
					         direction = "right";
					         
						     
					 }
			    	 if (i > 75 && i <= 100) {
					         direction = "down";
					        
					 }
			    	 
					     
			     }while(direction==ultimoMovimentoOpposto || gp.cCheck.checkCollisionWithWalls(this, direction));

			     
			     if(direction=="up") {
			    	 ultimoMovimentoOpposto="down";
			     }else if(direction=="down"){
			    	 ultimoMovimentoOpposto="up";
			     }else if(direction=="left") {
			    	 ultimoMovimentoOpposto="right";
			     }else if(direction=="right"){
			    	 ultimoMovimentoOpposto="left";
			     }
			     
			     
			     actionlockCounter = 0;

			 }
		}
		public void setAction() {
	    	randomMovement();
			    
		}
			

		
}